<style>

  body {
    --max-width-text-area: calc(300px - 2em);
    --max-height-text-area: calc(300px - 2em);
  }

  textarea {
    width: var(--max-width-text-area);
    max-width: var(--max-width-text-area);
    min-width: var(--max-width-text-area);
    height: var(--max-height-text-area);
    max-height: var(--max-height-text-area);
    min-height: var(--max-height-text-area);
    padding: 1em;
  }

  .row {
    display: flex;
    flex-direction: row;
  }

  .space-between {
    justify-content: space-between;
  } 
  
  .center-align {
    align-items: center;
  } 

  .col {
    display: flex;
    flex-direction: column;
  }

  .gap1 {
    gap: 1em;
  }

  .gap_5 {
    gap: .5em;
  }

  .stickTop {
    position: sticky;
    width: 100%;
    background: #fff;
    top: 0;
    border-bottom: 1px solid #000;
  }

  .stickTop button {
    height: fit-content;
    width: fit-content;
  }

  form {
    padding-top: 1em;
  }

</style>

<script>

  let pillars = `
(1) Standing during obligatory prayers if one is able to do so

(2) The opening takbeer (saying “Allahu akbar”)

(3) Reciting al-Faatihah

(4) Rukoo’ (bowing), the least of which means bending so that the hands can touch the knees, but the most complete form means making the back level and the head parallel with it.

(5) Rising from bowing

(6) Standing up straight

(7) Sujood (prostration), the most perfect form of which is placing the forehead, nose, palms, knees and toes firmly on the ground, and the least of which is placing a part of each of these on the ground.

(8) Rising from prostration

(9) Sitting between the two prostrations. However one sits is good enough, but the Sunnah is to sit muftarishan, which means sitting on the left foot and holding the right foot upright with the toes pointing towards the qiblah.

(10) Being at ease in each of these physical pillars

(11) The final tashahhud

(12) Sitting to recite the final tashahhud and the two salaams

(13) The two salaams. This means saying twice, “al-salaamu ‘alaykum wa rahmat-Allah (Peace be upon you and the mercy of Allah).” In naafil prayers it is sufficient to say one salaam; the same also applies to the funeral prayer.

(14) Doing the pillars in the order mentioned here. If a person deliberately prostrates before bowing, for example, the prayer is invalidated; if he does that by mistake, he has to go back and bow, and then prostrate.  
  `

  let obligatory = `
  
  (1) Takbeers other than the opening takbeer

(2) Saying “Sami’a Allahu liman hamidah (Allah hears those who praise Him” – for the imam and for the one who is praying alone.

(3) Saying “Rabbana wa laka’l-hamd (Our Lord, to You be praise)”

(4) Saying “Subhaana rabbiy al-‘azeem (Glory be to my Lord Almighty)” once when bowing

(5) Saying “Subhaana rabbiy al-a’laa (Glory be to my Lord most High)” once when prostrating

(6) Saying “Rabb ighfir li (Lord forgive me)” between the two prostrations

(7) The first tashahhud

(8) Sitting for the first tashahhud
  
  `

  let conditions = `
  
  (1) Islaam

  (2) Sanity 

  (3) Reaching the age of Maturity 

  (4) Being in a state of Ritual Impurity (i.e. Ablution)

  (5) Removal of Filth

  (6) Covering the ‘Awrah;

  (7) The Entrance of the Proper Time

  (8) Facing the Qiblah 

  (9) Having the correct Intention
  
  `

  const convertIntoJsonObject = (str) => {
    let singleLines = str.split('\n').filter(line=>line.length && !/(^\s+)(\s+$)/.test(line)).map(item=>item.replace(/^\s+|\s+$/, ''));
    let obj = singleLines.reduce((s, l, i)=>{
      s[i] = l;
      return s;
    }, {})
    return obj;
  }

  let pillarsStr = JSON.stringify(convertIntoJsonObject(pillars));
  let obligStr = JSON.stringify(convertIntoJsonObject(obligatory));
  let condStr = JSON.stringify(convertIntoJsonObject(conditions));

  let mode = 'pill';

  let cond = { s:{ r: 0, g: 114/255, b: 12/255 }, f:{ r: 139/255, g: 255/255, b: 151/255 } }
  let pill = { s:{ r: 4/255, g: 112/255, b: 173/255 }, f:{ r: 139/255, g: 213/255, b: 255/255 } }
  let obl = { s:{ r: 173/255, g: 4/255, b: 4/255 }, f:{ r: 255/255, g: 188/255, b: 139/255 } }

</script>

<script>

  let stylingOpts = {
    padding: {value:0, type:'number', min:0},
    width: {value:-1, type:'number', min:-1},
    height: {value:-1, type:'number', min:-1},
    // strokes: {value:[{ type: 'SOLID', color: mode==='cond' ? cond.s : mode==='pill' ? pill.s : obl.s }], type:'figma-colour'},
    strokes: {value:[], type:'figma-colour'},
    strokeWeight:{value:1, type:'number', min:0},
    fills: {value:[], type:'figma-colour'},
    cornerRadius: {value:[0, 0, 0, 0], type:'number-option-4', min:0 },
    fontSize: {value:12, type:'number', min:1 }
    // textStyling: {value:[{type:'font', value:{ family: "Roboto", style: "Regular" }}], type:'font', min:1 },
  }

  let containerStylingOpts = {
    padding: {value:0, type:'number', min:0},
    gap: {value:10, type:'number', min:0},
    width: {value:-1, type:'number', min:-1},
    strokes: {value:[], type:'figma-colour'},
    strokeWeight:{value:0, type:'number', min:0, max:3},
    fills: {value:[], type:'figma-colour'},
    cornerRadius: {value:[0, 0, 0, 0], type:'number-option-4', min:0 },
    align: {value:'vertical', type:'select-options', options:['vertical', 'horizontal', 'zigzag', 'diagonal']},
  }

  let blockStylingOpts = {
    gap:{value:10, type:'number', defaultVisibility:'flex' },
    produceOne: {value:false, type:'boolean', hideItem:'*', hideOn:true, defaultVisibility:'flex' },
    quantity: { value:1, type:'number', min:1, defaultVisibility:'flex' },
    randomValues: { value:true, type:'boolean', defaultVisibility:'flex' },
    displayAsGrid: { value:false, type:'boolean', hideItem:['gridTemplateColumns', 'gridTemplateRows'], hideOn:false, defaultVisibility:'flex' },
    gridTemplateColumns: { value:1, type:'number', defaultVisibility:'none' },
    gridTemplateRows: { value:1, type:'number', defaultVisibility:'none' },
    displayAsFlex: { value:true, type:'boolean', hideItem:['flexRow', 'flexColumn'], hideOn:false, defaultVisibility:'flex' },
    flexRow: { value:false, type:'boolean' },
    flexColumn: { value:true, type:'boolean', defaultVisibility:'flex' },
    matchAllWidths: { value:true, type:'boolean', defaultVisibility:'flex' },
    matchAllHeights: { value:true, type:'boolean', defaultVisibility:'flex' },
    startFromX: { value:100, type:'number', defaultVisibility:'flex' },
    startFromY: { value:100, type:'number', defaultVisibility:'flex' },
  }



  const convertObjectIntoCollectionArr = (obj, meta={}) => 
    Object.keys(obj).map(key=> Object.assign(
        { type:'text', value:obj[key], key }, 
        meta.hasOwnProperty(key) ? meta[key] : {} 
    ))

  

  const produceKeyForm = (object, stylingOptions) => {
    let duplicateObj = {  };
    for (let k in object) {
      duplicateObj[k] = JSON.parse(JSON.stringify(stylingOptions));
    }
    return duplicateObj
  }




  const convertHexToFigmaRGB = (hex) => {
    // https://stackoverflow.com/questions/58184508/html5-input-type-color-read-single-rgb-values
    const r = parseInt(hex.substr(1,2), 16)
    const g = parseInt(hex.substr(3,2), 16)
    const b = parseInt(hex.substr(5,2), 16)
    return [{type:'SOLID', color:{ r:r/255, g:g/255, b:b/255 }}]
  }
  
  const produceInputFields = (fields, form, parentField, manageClassData=false) => {
    const root = document.documentElement;
    Object.keys(fields).forEach(key=>{
      let { value, type, max, min, hideItem, hideOn, defaultVisibility } = fields[key];
      let container = document.createElement('div');
      container.className = 'row gap1 space-between'
      let label = document.createElement('label')
      label.innerText = key;
      container.appendChild(label);

      if (manageClassData) {
        let viewProperty = `--figma-design-generator-var-${key}`
        root.style.setProperty(viewProperty, defaultVisibility !== undefined ? defaultVisibility : 'flex');
        container.style.display = `var(${viewProperty})`
      }

      if (type==='number') {
        let inputField = document.createElement('input');
        inputField.type = 'number';
        inputField.value = value;
        if (max!==undefined) inputField.max = max;
        if (min!==undefined) inputField.min = min;
        inputField.onchange = (e)=>{
            fields[key].value = parseInt(e.target.value);
        };
        container.appendChild(inputField);
      }else if (type==='figma-colour') {

        let inputField = document.createElement('input');
        inputField.type = 'color';
        inputField.value = value;

        inputField.onchange = (e)=>{
          fields[key].value = convertHexToFigmaRGB(e.target.value);
        };

        container.appendChild(inputField);
      
      }
      else if (type==='boolean') {
        let selectBlock = document.createElement('select');
        let trueOpt = document.createElement('option');
        let falseOpt = document.createElement('option');
        trueOpt.innerText = "Yes";
        falseOpt.innerText = "No";
        selectBlock.appendChild(trueOpt);
        selectBlock.appendChild(falseOpt);
        selectBlock.value = fields[key].value ? 'Yes' : 'No';
        selectBlock.onchange = (e)=>{
            fields[key].value = e.target.value === 'Yes' ? true : false;
            // hideItem, hideOn
            if (manageClassData && hideItem!==undefined) {
                let fieldsFound = [];
                let valueToSet = fields[key].value===hideOn ? 'none' : 'flex';
                fieldsFound = hideItem==='*' ? Object.keys(fields).filter(key_=>key_!==key) : hideItem;
                fieldsFound.forEach(f=>{
                  root.style.setProperty(`--figma-design-generator-var-${f}`, valueToSet);
                })
            }
        };
        container.appendChild(selectBlock);
      }
      else if (/^number-option-(\d+)$/.test(type)) {

        let miniParent = document.createElement('div');
        miniParent.className = 'row'
        for (let k = 0; k < value.length; k++) {
          let inputField = document.createElement('input');
          inputField.type = 'number';
          inputField.value = value[k];
          inputField.onchange = (e)=>{
            fields[key].value[k] = parseInt(e.target.value);
          };
          inputField.style.width = '40px'
          if (min!==undefined) {
            inputField.min = min;
          }
          if (max!==undefined) {
            inputField.min = min;
          }          
          miniParent.appendChild(inputField);
        }

        container.appendChild(miniParent);

      }

      form.appendChild(container)
    })
  }

  const produceTemplateBlock = (styleForm, manageClassData=false) => {

    Object.keys(styleForm).forEach((item, i)=>{

      let parent = document.createElement('div');
      parent.style.position = 'relative';
      let header = document.createElement('h3');

      let miniNav = document.createElement('div');
      miniNav.className = 'row'
      miniNav.appendChild(header);
      miniNav.className = 'stickTop row gap1 center-align'

      header.innerHTML = item;
      header.style.width = '100%';
      parent.appendChild(miniNav);

      let form = document.createElement('form');
      form.className = 'dynamic-form col gap_5'

      let toggleButton = document.createElement('button');
      toggleButton.innerText = "Hide"
      toggleButton.onclick = () => {
        form.style.display = !form.style.display.length || form.style.display === 'flex' ? 'none' : 'flex'
      }

      miniNav.appendChild(toggleButton);


      parent.appendChild(form);

      // styleForm[item] = { ...styleForm[item] }

      produceInputFields(styleForm[item], form, item, manageClassData);

      document.getElementById('main').append(parent);


    })
  }

  const grabValueField = (item) => {
    let newItem = JSON.parse(JSON.stringify(item))
    Object.keys(newItem).forEach((it)=>{
      let properties = newItem[it];
      Object.keys(properties).forEach((prop)=>{
        properties[prop] = properties[prop].value;
      })
    });
    return newItem;
  }

  const checkDimensionOptions = (styling, containerOptions) => {


      if (containerOptions.container.width > -1){

        Object.keys(styling).forEach(id=>{
          styling[id].width = containerOptions.container.width;
          console.log('after', containerOptions.container.width, styling[id].width)
        })
      }
      
      if (containerOptions.container.height > -1){
        Object.keys(styling).forEach(id=>{
          styling[id].height = containerOptions.container.height;
        })
      }

  }

  const unifyUserInput = (userFields, fieldStyling, containerStyling, blockOptions, allBlocks) => {

    if (!Array.isArray(userFields)) {
      userFields = [userFields];
    } 

    let containerStylingValue = grabValueField(containerStyling);
    let blocks = userFields.map(fields=>
      {
          let newStyling = grabValueField({...fieldStyling});
          checkDimensionOptions(newStyling, containerStylingValue);
          console.log(newStyling);
          return {contents: convertObjectIntoCollectionArr(fields, newStyling)}
      }
    )

    let outputData = {
      blocks,
      ...containerStylingValue.container,
    }

    parent.postMessage({ pluginMessage: { type: 'create-block', value:outputData } }, '*')

  }

</script>

<div class="stickTop row gap1">
  <button id="create">Create</button>
  <button id="cancel">Cancel</button>
</div>

<div id="main">
  <h2>Enter JSON template below</h2>
  <textarea id="json" value="5"></textarea>
  <p></p>
</div>



<script>

document.getElementById('json').value = 
// mode==='cond' ? condStr : mode==='pill' ? pillarsStr : obligStr
`[
  
{
  "name":"My name is Momodou!",
  "age":"3232",
  "message": "Hello world, how is it going?",
  "another": "Hello world, how is it going?",
  "another2": "Hello world, how is it going?",
  "another3": "short",
  "another3": "lorem ipsum something garbage and yes thats all good!"
},

{
  "name":"My name is John!",
  "age":"3232",
  "message": "Hello world, how is it going?",
  "another": "Hello world, how is it going?",
  "another2": "Hello world, how is it going?",
  "another3": "short",
  "another3": "lorem ipsum something garbage and yes thats all good!"
}


]
`




document.getElementById('create').onclick = () => {
    
  const textbox = document.getElementById('json');

  if (!textbox.value) {
    alert("nothing to do here!")
    return;
  }

  let stepOneData = JSON.parse(textbox.value);
  let allComponents = Array.isArray(stepOneData) ? [...stepOneData] : [{...stepOneData}];
  if (Array.isArray(stepOneData)) {
    stepOneData = stepOneData[0];
  }

  let keyForm = produceKeyForm(stepOneData, stylingOpts)
  let containerKeyForm = produceKeyForm({ container:null }, containerStylingOpts);
  let blockKeyForm = produceKeyForm({ block:null }, blockStylingOpts);
  // document.getElementById('create').onclick = () => extractInputs(keyForm)
  document.getElementById('create').innerText = "Manage container"
  document.getElementById('create').onclick = () => {

    document.getElementById('main').innerHTML = ""
    produceTemplateBlock(containerKeyForm);
    document.getElementById('create').innerText = "Manage Blocks"

    document.getElementById('create').onclick = () => {
        document.getElementById('create').innerText = "Generate Items"
        document.getElementById('main').innerHTML = ""
        produceTemplateBlock(blockKeyForm, true);

        document.getElementById('create').onclick = () => {

            // document.getElementById('create').innerText = "Generate Items"
            // document.getElementById('main').innerHTML = ""
            unifyUserInput(allComponents, keyForm, containerKeyForm, blockKeyForm);

        }
          
        // unifyUserInput

    }
  
  }

  document.getElementById('main').innerHTML = ""
  produceTemplateBlock(keyForm);


}

document.getElementById('cancel').onclick = () => {
  parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*')
}
</script>

